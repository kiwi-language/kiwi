package innerclass

class InnerClassFoo<K, V> {

    val entries: Entry<K, V>[] = new Entry<K, V>[]

    fn addEntry(key: K, value: V) {
        entries.append(Entry<K, V>(key, value))
    }

    fn iterator() -> Iterator<Entry<K, V>> {
        return MyIterator()
    }

    fn first() -> Entry<K, V> {
        var it = iterator()
        if (it.hasNext()) return it.next()
        throw Exception("No such element")
    }

    class Entry<K, V>(
            var key: K,
            var value: V
    ) {

        fn getKey() -> K {
            return key
        }

        fn setKey(key: K) {
            this.key = key
        }

        fn getValue() -> V {
            return value
        }

        fn setValue(value: V) {
            this.value = value
        }

    }

    interface Iterator<E> {

        fn next() -> E

        fn hasNext() -> bool

    }

    temp class MyIterator: Iterator<Entry<K,V>> {

        priv var i = 0

        fn hasNext() -> bool {
            return i < entries.length
        }

        fn next() -> Entry<K, V> {
            return entries[i++]
        }

        fn copy() -> MyIterator {
            return MyIterator()
        }

    }

}

