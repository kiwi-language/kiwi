package anonymous_class


class AnonymousClassFoo<K, V> {

    priv val entries: Entry[] = new Entry[]

    static fn create<K, V>(entries: EntryDTO<K, V>[]) -> AnonymousClassFoo<K, V> {
        var foo = AnonymousClassFoo<K, V>()
        for (entry in entries) {
            foo.Entry(entry.key(), entry.value())
        }
        return foo
    }

    fn keysSnapshot() -> Iterable<K> {
        var a0 = new Entry[]
        for (e in entries)
            a0.append(e)
        return new Iterable<K>() {

            fn iterator() -> Iterator<K> {
                return new Iterator<K>() {

                    priv var i = 0

                    fn hasNext() -> bool {
                        return i < a0.length
                    }

                    fn next() -> K {
                        return a0[i++].key()
                    }

                }
            }

        }
    }

    fn concatKeys() -> string {
        var it = keysSnapshot().iterator()
        var r = ""
        while (it.hasNext()) {
            if (!r.isEmpty()) r = r + ","
            r = r + it.next()
        }
        return r
    }

    class Entry(
            priv val key: K,
            priv val value: V
    ) {

        {
            entries.append(this)
        }

        fn key() -> K {
            return key
        }

        fn value() -> V {
            return value
        }

    }

}

interface Iterable<E> {

    fn iterator() -> Iterator<E>

}

interface Iterator<E> {

    fn next() -> E

    fn hasNext() -> bool

}

