symbol.not.found=Symbol not found
ambiguous.reference=Ambiguous reference with multiple matches: {0}
unexpected.char=Unexpected character: ''{0}''
unexpected.token=Unexpected token: {0}
invalid.escape=Invalid escape ''\\{0}''
unclosed.comment=Unclosed comment
invalid.unicode.escape="Invalid unicode escape ''\\u{0}''
malformed.float.literal="Malformed float-point literal"
expected={0} expected
expected2={0} or {1} expected
expected3={0}, {1}'' or {2} expected
expected4={0}, {1}, {2} or {3} expected
illegal.start.of.expr=Illegal start of expression
illegal.start.of.type=Illegal start of type
illegal.start.of.stmt=Illegal start of statement
illegal.new.expr=Illegal new expression
cant.resolve.expr=Cannot resolve expression
cant.resolve.symbol=Cannot resolve symbol
duplicate.binding.name=Duplicate binding name
cant.resolve.func=Cannot resolve function
cant.resolve.func.with.arg.types=Cannot resolve function with given argument types: {0}
debug1=debug: {0}
illegal=Illegal ''{0}''
foreach.not.applicable.to.type=For-each not applicable to type ''{0}''
variable.must.typed.or.initialized=Variable must either have a type annotation or be initialized
summary.field.must.be.string=Summary field must be string
cant.modify.captured.var=Cannot modify a captured variable
cant.apply.symbol=No suitable function found for {0}
cant.find.constructor=Cannot find constructor in {0} with given argument types: {1}
type.checking.circular.ref=Type checking has run into a recursive problem. Easiest workaround: specify types of your declarations explicitly
modifier.not.allowed.here=Modifier ''{0}'' is not allowed here
unexpected.type=Unexpected type
non.static.index.field=Index field must be static
misplaced.index.field=Index field must be defined in the class it indexes
invalid.index.value.type=Invalid index value type
reserved.field.name=Reserved field name
illegal.cast=Illegal cast from {0} to {1}
field.not.initialized=Field not initialized
illegal.use.of.type=Illegal use of type
operator.cant.be.applied1=Operator ''{0}'' cannot be applied to ''{1}''
operator.cant.be.applied2=Operator ''{0}'' cannot be applied to ''{1}'', ''{2}''
incompatible.types=Incompatible types: {0} cannot be converted to {1}
void.initializer=Variable initializer is ''void''
variable.already.defined=Variable ''{0}'' is already defined in the scope
function.already.defined=Function ''{0}'' is already defined in the scope

# Sense lint
sense-lint.variable.name.ends.with.id=Variable name ending with ''Id'' is not allowed
sense-lint.variable.name.matches.class.name=Variable name matches a class name but its type is not the class, such confusing naming is not allowed
sense-lint.variable.name.matches.plural.class.name=Variable name matches the plural form of a class name but its type is not the array type of the class, such confusing naming is not allowed
